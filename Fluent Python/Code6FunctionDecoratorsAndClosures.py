# from numba import jit, cuda
# @jit(target = "cuda")
#To use GPU
#Function Decorators and Closures
#Help in <marking> functions in the SRC code to enhance behaviour 
#Decorators 101
# @decorate
# def target():
#     print("running target()")

# def target():
#     print("running target()")
# target = decorate(target)

def deco(func):
    def inner():
        print('Running inner() function')
    return inner

@deco
def target():
    print("running target() function")

print(target())
print(target)
#Gettin to know all the functions that are present right now
print([globals()[name] for name in globals()])
#Decorator - returns its inner function object 

#Execution of Decorators
registry = []

def register(func):
    print('running register(%s)'%func)
    registry.append(func)
    return func

#decorator
@register
def f1():
    print('running f1()')

@register
def f2():
    print('running f2()')

def f3():
    print('running f3()')

def main():
    print('running main()')
    print('registery->', registry)
    f1()
    f2()
    f3()

# if __name__ == '__main__':
#     main()


#Decorator Enhanced Strategy Plan
from abc import ABC, abstractmethod
from collections import namedtuple
from math import dist, prod
from types import new_class

Customer = namedtuple('Customer', 'name fidelity')

class LineItem:
    def __init__(self, product, quantity, price):
        self.product = product
        self.quantity = quantity
        self.price = price
    
    def total(self):
        return self.price*self.quantity
    
class Order: #Context
    def __init__ (self, customer, cart, promotion = None):
        self.customer = customer
        self.cart = list(cart)
        self.promotion = promotion
    
    def total(self):
        """"This method creates the total iff it is not created"""
        if not hasattr(self, '__total'):
            self.__total = sum(item.total() for item in self.cart)
        return self.__total
    
    def due(self):
        if self.promotion == None:
            discount = 0
        else:
            discount = self.promotion.discount(self)
        return self.total() - discount
    
    def __repr__ (self):
        fmt = "Order total: {:.2f} due: {:.2f}>"
        return fmt.format(self.total(), self.due())

#in this case there will be always at the time of init, the list of promos
#available will be constructed and then only the program starts execution
#We can enable and disable promotion using COMMENTING IT OUT

promos = []
def promotion(promo_func):
    """This function will be invoked first, if ran as a script"""
    promos.append(promo_func)
    return promo_func

@promotion
def fidelity(order):
    return order.total()*.05 if order.customer.fidelity>= 1000 else 0

@promotion
def bulk_item(order):
    discount = 0
    for item in order.cart:
        if item.quantity>= 20:
            discount += item.total()*.1
    return discount

@promotion
def large_order(order):
    distinct_items = {item.product for item in order.cart}
    if len(distinct_items) >= 10:
        return order.total()*.07
    return 0

def best_promo(order):
    return max(promo(order) for promo in promos)

#Function Scoping and Closures
#Local Variable's value are searched before the global values are searched
#Generated ByteCode will fetch from the local environment value of b first
#Accessing ByteCode
from dis import dis
print(dis(best_promo))

#Average Closures
#Class based Implementation
class Averager():
    def __init__ (self):
        self.series = []

    def __call__ (self, new_value):
        self.series.append(new_value)
        total = sum(self.series)
        return total/len(self.series)

avg = Averager()
print(avg(10), avg(11), avg(12))

#Running average Higher Order Function
def make_averager():
    series = []    ###### Closure

    def averager(new_value):
        series.append(new_value)  ###### Free Variable
        total = sum(series)
        return total/len(series)
    return averager

avg = make_averager()
print(avg(10), avg(11), avg(12))

#series in averager is a free variable, not the part of local scope 
#but can access since it was defined in its function above.

print(avg.__code__.co_varnames)
print(avg.__code__.co_freevars)
print(avg.__closure__[0].cell_contents)

#Closure is a function that retains the bindings of the free variable
#that exits when the function is defined so that they can bes used later
#when the function is invoked as a free variable and defining scope
#is no longer available as the local variable environment space


#To make the IMMUTABLE types as the free variable we can use the 
#keyword NONLOCAL so that we can access them also as the part of
#free variable space

def make_averager_immutenonlocal():
    count, total = 0, 0

    def averager_immutenonlocal(new_value):
        # keyword <nonlocal> helps in FLAGGING the outside vars as freevars
        nonlocal count, total
        count += 1
        total += new_value
        return total/count
    
    return averager_immutenonlocal
    
#Decorator Implementation
import time

#Clock Decorator
def clock(func):
    func = func
    def clocked(*args):
        t0 = time.perf_counter()
        result = func(*args)
        elapsed = time.perf_counter()

        name = func.__name__
        arg_str = ', '.join(repr(arg) for arg in args)
        print('[%0.8fs] %s(%s) -> %r' % (elapsed, name, arg_str, result))
        return result
    return clocked

import time
from Code6ExtraDecoratorClass import clock

@clock
def snooze(seconds):
    time.sleep(seconds)

@clock
def factorial(n):
    return 1 if n<2 else n*factorial(n-1)

# if __name__ == '__main__':
#     print('*' * 40, 'Calling snooze(.123)')    
#     snooze(.123)    
#     print('*' * 40, 'Calling factorial(6)')
#     print('6! =', factorial(6))


#Decorators in Standard Library
#Memoization with functools.lru_cache
#Optimization tech - Saves prev results of expensive functions
from Code6ExtraDecoratorClass import clock

@clock
def fibonacci(n):
    if n<2:
        return n
    return fibonacci(n-2) + fibonacci(n-1)

# if __name__ == '__main__':
#     print(fibonacci(6))

#Faster implementation using Caching
import functools
from Code6ExtraDecoratorClass import clock

#Stack Decorators
@functools.lru_cache()
@clock
def fibonacci_lru(n):
    if n<2:
        return n
    return fibonacci_lru(n-2) + fibonacci_lru(n-1)

if __name__ == '__main__':
    print(fibonacci_lru(6))

from dis import dis
print(dis(fibonacci_lru))
#print(fibonacci(30))
print(fibonacci_lru(30))

#Decorators <functool.singledispatch>
import html

def htmlize(obj):
    content = html.escape(repr(obj))
    return '<pre>{}</pre>'.format(content)

#Paramerized Decorators
#Since we can only pass the func in decorator, so we crate a false
#decorator enclosing the true decorator

registry = {}
def register(active=True):
    def decorate(func):
        #---snip---
        return func
    return decorate

# @registry(active = False)
# @registry() # by default true

